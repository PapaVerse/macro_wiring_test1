import {
    e as qe,
    a as $
} from "./chunk-CMjeC7eR.js";
import {
    s as Ge
} from "./chunk-BPB3WYz4.js";
const y = i => typeof i == "string",
    Y = () => {
        let i, e;
        const t = new Promise((s, n) => {
            i = s, e = n
        });
        return t.resolve = i, t.reject = e, t
    },
    xe = i => i == null ? "" : "" + i,
    Xe = (i, e, t) => {
        i.forEach(s => {
            e[s] && (t[s] = e[s])
        })
    },
    et = /###/g,
    Se = i => i && i.indexOf("###") > -1 ? i.replace(et, ".") : i,
    be = i => !i || y(i),
    Q = (i, e, t) => {
        const s = y(e) ? e.split(".") : e;
        let n = 0;
        for (; n < s.length - 1;) {
            if (be(i)) return {};
            const r = Se(s[n]);
            !i[r] && t && (i[r] = new t), Object.prototype.hasOwnProperty.call(i, r) ? i = i[r] : i = {}, ++n
        }
        return be(i) ? {} : {
            obj: i,
            k: Se(s[n])
        }
    },
    we = (i, e, t) => {
        const {
            obj: s,
            k: n
        } = Q(i, e, Object);
        if (s !== void 0 || e.length === 1) {
            s[n] = t;
            return
        }
        let r = e[e.length - 1],
            a = e.slice(0, e.length - 1),
            o = Q(i, a, Object);
        for (; o.obj === void 0 && a.length;) r = `${a[a.length-1]}.${r}`, a = a.slice(0, a.length - 1), o = Q(i, a, Object), o ? .obj && typeof o.obj[`${o.k}.${r}`] < "u" && (o.obj = void 0);
        o.obj[`${o.k}.${r}`] = t
    },
    tt = (i, e, t, s) => {
        const {
            obj: n,
            k: r
        } = Q(i, e, Object);
        n[r] = n[r] || [], n[r].push(t)
    },
    te = (i, e) => {
        const {
            obj: t,
            k: s
        } = Q(i, e);
        if (t && Object.prototype.hasOwnProperty.call(t, s)) return t[s]
    },
    st = (i, e, t) => {
        const s = te(i, t);
        return s !== void 0 ? s : te(e, t)
    },
    Ue = (i, e, t) => {
        for (const s in e) s !== "__proto__" && s !== "constructor" && (s in i ? y(i[s]) || i[s] instanceof String || y(e[s]) || e[s] instanceof String ? t && (i[s] = e[s]) : Ue(i[s], e[s], t) : i[s] = e[s]);
        return i
    },
    H = i => i.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var nt = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
};
const it = i => y(i) ? i.replace(/[&<>"'\/]/g, e => nt[e]) : i;
class rt {
    constructor(e) {
        this.capacity = e, this.regExpMap = new Map, this.regExpQueue = []
    }
    getRegExp(e) {
        const t = this.regExpMap.get(e);
        if (t !== void 0) return t;
        const s = new RegExp(e);
        return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, s), this.regExpQueue.push(e), s
    }
}
const at = [" ", ",", "?", "!", ";"],
    ot = new rt(20),
    lt = (i, e, t) => {
        e = e || "", t = t || "";
        const s = at.filter(a => e.indexOf(a) < 0 && t.indexOf(a) < 0);
        if (s.length === 0) return !0;
        const n = ot.getRegExp(`(${s.map(a=>a==="?"?"\\?":a).join("|")})`);
        let r = !n.test(i);
        if (!r) {
            const a = i.indexOf(t);
            a > 0 && !n.test(i.substring(0, a)) && (r = !0)
        }
        return r
    },
    de = (i, e, t = ".") => {
        if (!i) return;
        if (i[e]) return Object.prototype.hasOwnProperty.call(i, e) ? i[e] : void 0;
        const s = e.split(t);
        let n = i;
        for (let r = 0; r < s.length;) {
            if (!n || typeof n != "object") return;
            let a, o = "";
            for (let l = r; l < s.length; ++l)
                if (l !== r && (o += t), o += s[l], a = n[o], a !== void 0) {
                    if (["string", "number", "boolean"].indexOf(typeof a) > -1 && l < s.length - 1) continue;
                    r += l - r + 1;
                    break
                }
            n = a
        }
        return n
    },
    q = i => i ? .replace("_", "-"),
    ut = {
        type: "logger",
        log(i) {
            this.output("log", i)
        },
        warn(i) {
            this.output("warn", i)
        },
        error(i) {
            this.output("error", i)
        },
        output(i, e) {
            console ? .[i] ? .apply ? .(console, e)
        }
    };
class se {
    constructor(e, t = {}) {
        this.init(e, t)
    }
    init(e, t = {}) {
        this.prefix = t.prefix || "i18next:", this.logger = e || ut, this.options = t, this.debug = t.debug
    }
    log(...e) {
        return this.forward(e, "log", "", !0)
    }
    warn(...e) {
        return this.forward(e, "warn", "", !0)
    }
    error(...e) {
        return this.forward(e, "error", "")
    }
    deprecate(...e) {
        return this.forward(e, "warn", "WARNING DEPRECATED: ", !0)
    }
    forward(e, t, s, n) {
        return n && !this.debug ? null : (y(e[0]) && (e[0] = `${s}${this.prefix} ${e[0]}`), this.logger[t](e))
    }
    create(e) {
        return new se(this.logger, {
            prefix: `${this.prefix}:${e}:`,
            ...this.options
        })
    }
    clone(e) {
        return e = e || this.options, e.prefix = e.prefix || this.prefix, new se(this.logger, e)
    }
}
var V = new se;
class re {
    constructor() {
        this.observers = {}
    }
    on(e, t) {
        return e.split(" ").forEach(s => {
            this.observers[s] || (this.observers[s] = new Map);
            const n = this.observers[s].get(t) || 0;
            this.observers[s].set(t, n + 1)
        }), this
    }
    off(e, t) {
        if (this.observers[e]) {
            if (!t) {
                delete this.observers[e];
                return
            }
            this.observers[e].delete(t)
        }
    }
    emit(e, ...t) {
        this.observers[e] && Array.from(this.observers[e].entries()).forEach(([n, r]) => {
            for (let a = 0; a < r; a++) n(...t)
        }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(([n, r]) => {
            for (let a = 0; a < r; a++) n.apply(n, [e, ...t])
        })
    }
}
class Oe extends re {
    constructor(e, t = {
        ns: ["translation"],
        defaultNS: "translation"
    }) {
        super(), this.data = e || {}, this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0)
    }
    addNamespaces(e) {
        this.options.ns.indexOf(e) < 0 && this.options.ns.push(e)
    }
    removeNamespaces(e) {
        const t = this.options.ns.indexOf(e);
        t > -1 && this.options.ns.splice(t, 1)
    }
    getResource(e, t, s, n = {}) {
        const r = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator,
            a = n.ignoreJSONStructure !== void 0 ? n.ignoreJSONStructure : this.options.ignoreJSONStructure;
        let o;
        e.indexOf(".") > -1 ? o = e.split(".") : (o = [e, t], s && (Array.isArray(s) ? o.push(...s) : y(s) && r ? o.push(...s.split(r)) : o.push(s)));
        const l = te(this.data, o);
        return !l && !t && !s && e.indexOf(".") > -1 && (e = o[0], t = o[1], s = o.slice(2).join(".")), l || !a || !y(s) ? l : de(this.data ? .[e] ? .[t], s, r)
    }
    addResource(e, t, s, n, r = {
        silent: !1
    }) {
        const a = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator;
        let o = [e, t];
        s && (o = o.concat(a ? s.split(a) : s)), e.indexOf(".") > -1 && (o = e.split("."), n = t, t = o[1]), this.addNamespaces(t), we(this.data, o, n), r.silent || this.emit("added", e, t, s, n)
    }
    addResources(e, t, s, n = {
        silent: !1
    }) {
        for (const r in s)(y(s[r]) || Array.isArray(s[r])) && this.addResource(e, t, r, s[r], {
            silent: !0
        });
        n.silent || this.emit("added", e, t, s)
    }
    addResourceBundle(e, t, s, n, r, a = {
        silent: !1,
        skipCopy: !1
    }) {
        let o = [e, t];
        e.indexOf(".") > -1 && (o = e.split("."), n = s, s = t, t = o[1]), this.addNamespaces(t);
        let l = te(this.data, o) || {};
        a.skipCopy || (s = JSON.parse(JSON.stringify(s))), n ? Ue(l, s, r) : l = { ...l,
            ...s
        }, we(this.data, o, l), a.silent || this.emit("added", e, t, s)
    }
    removeResourceBundle(e, t) {
        this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit("removed", e, t)
    }
    hasResourceBundle(e, t) {
        return this.getResource(e, t) !== void 0
    }
    getResourceBundle(e, t) {
        return t || (t = this.options.defaultNS), this.getResource(e, t)
    }
    getDataByLanguage(e) {
        return this.data[e]
    }
    hasLanguageSomeTranslations(e) {
        const t = this.getDataByLanguage(e);
        return !!(t && Object.keys(t) || []).find(n => t[n] && Object.keys(t[n]).length > 0)
    }
    toJSON() {
        return this.data
    }
}
var Ke = {
    processors: {},
    addPostProcessor(i) {
        this.processors[i.name] = i
    },
    handle(i, e, t, s, n) {
        return i.forEach(r => {
            e = this.processors[r] ? .process(e, t, s, n) ? ? e
        }), e
    }
};
const Me = Symbol("i18next/PATH_KEY");

function ct() {
    const i = [],
        e = Object.create(null);
    let t;
    return e.get = (s, n) => (t ? .revoke ? .(), n === Me ? i : (i.push(n), t = Proxy.revocable(s, e), t.proxy)), Proxy.revocable(Object.create(null), e).proxy
}

function ne(i, e) {
    const {
        [Me]: t
    } = i(ct());
    return t.join(e ? .keySeparator ? ? ".")
}
const ve = {},
    oe = i => !y(i) && typeof i != "boolean" && typeof i != "number";
class ie extends re {
    constructor(e, t = {}) {
        super(), Xe(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e, this), this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = V.create("translator")
    }
    changeLanguage(e) {
        e && (this.language = e)
    }
    exists(e, t = {
        interpolation: {}
    }) {
        const s = { ...t
        };
        if (e == null) return !1;
        const n = this.resolve(e, s);
        if (n ? .res === void 0) return !1;
        const r = oe(n.res);
        return !(s.returnObjects === !1 && r)
    }
    extractFromKey(e, t) {
        let s = t.nsSeparator !== void 0 ? t.nsSeparator : this.options.nsSeparator;
        s === void 0 && (s = ":");
        const n = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator;
        let r = t.ns || this.options.defaultNS || [];
        const a = s && e.indexOf(s) > -1,
            o = !this.options.userDefinedKeySeparator && !t.keySeparator && !this.options.userDefinedNsSeparator && !t.nsSeparator && !lt(e, s, n);
        if (a && !o) {
            const l = e.match(this.interpolator.nestingRegexp);
            if (l && l.length > 0) return {
                key: e,
                namespaces: y(r) ? [r] : r
            };
            const u = e.split(s);
            (s !== n || s === n && this.options.ns.indexOf(u[0]) > -1) && (r = u.shift()), e = u.join(n)
        }
        return {
            key: e,
            namespaces: y(r) ? [r] : r
        }
    }
    translate(e, t, s) {
        let n = typeof t == "object" ? { ...t
        } : t;
        if (typeof n != "object" && this.options.overloadTranslationOptionHandler && (n = this.options.overloadTranslationOptionHandler(arguments)), typeof n == "object" && (n = { ...n
            }), n || (n = {}), e == null) return "";
        typeof e == "function" && (e = ne(e, { ...this.options,
            ...n
        })), Array.isArray(e) || (e = [String(e)]);
        const r = n.returnDetails !== void 0 ? n.returnDetails : this.options.returnDetails,
            a = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator,
            {
                key: o,
                namespaces: l
            } = this.extractFromKey(e[e.length - 1], n),
            u = l[l.length - 1];
        let f = n.nsSeparator !== void 0 ? n.nsSeparator : this.options.nsSeparator;
        f === void 0 && (f = ":");
        const c = n.lng || this.language,
            p = n.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if (c ? .toLowerCase() === "cimode") return p ? r ? {
            res: `${u}${f}${o}`,
            usedKey: o,
            exactUsedKey: o,
            usedLng: c,
            usedNS: u,
            usedParams: this.getUsedParamsDetails(n)
        } : `${u}${f}${o}` : r ? {
            res: o,
            usedKey: o,
            exactUsedKey: o,
            usedLng: c,
            usedNS: u,
            usedParams: this.getUsedParamsDetails(n)
        } : o;
        const h = this.resolve(e, n);
        let d = h ? .res;
        const L = h ? .usedKey || o,
            O = h ? .exactUsedKey || o,
            E = ["[object Number]", "[object Function]", "[object RegExp]"],
            w = n.joinArrays !== void 0 ? n.joinArrays : this.options.joinArrays,
            N = !this.i18nFormat || this.i18nFormat.handleAsObject,
            S = n.count !== void 0 && !y(n.count),
            k = ie.hasDefaultValue(n),
            T = S ? this.pluralResolver.getSuffix(c, n.count, n) : "",
            C = n.ordinal && S ? this.pluralResolver.getSuffix(c, n.count, {
                ordinal: !1
            }) : "",
            g = S && !n.ordinal && n.count === 0,
            x = g && n[`defaultValue${this.options.pluralSeparator}zero`] || n[`defaultValue${T}`] || n[`defaultValue${C}`] || n.defaultValue;
        let m = d;
        N && !d && k && (m = x);
        const v = oe(m),
            b = Object.prototype.toString.apply(m);
        if (N && m && v && E.indexOf(b) < 0 && !(y(w) && Array.isArray(m))) {
            if (!n.returnObjects && !this.options.returnObjects) {
                this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
                const P = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(L, m, { ...n,
                    ns: l
                }) : `key '${o} (${this.language})' returned an object instead of string.`;
                return r ? (h.res = P, h.usedParams = this.getUsedParamsDetails(n), h) : P
            }
            if (a) {
                const P = Array.isArray(m),
                    A = P ? [] : {},
                    M = P ? O : L;
                for (const j in m)
                    if (Object.prototype.hasOwnProperty.call(m, j)) {
                        const R = `${M}${a}${j}`;
                        k && !d ? A[j] = this.translate(R, { ...n,
                            defaultValue: oe(x) ? x[j] : void 0,
                            joinArrays: !1,
                            ns: l
                        }) : A[j] = this.translate(R, { ...n,
                            joinArrays: !1,
                            ns: l
                        }), A[j] === R && (A[j] = m[j])
                    }
                d = A
            }
        } else if (N && y(w) && Array.isArray(d)) d = d.join(w), d && (d = this.extendTranslation(d, e, n, s));
        else {
            let P = !1,
                A = !1;
            !this.isValidLookup(d) && k && (P = !0, d = x), this.isValidLookup(d) || (A = !0, d = o);
            const j = (n.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && A ? void 0 : d,
                R = k && x !== d && this.options.updateMissing;
            if (A || P || R) {
                if (this.logger.log(R ? "updateKey" : "missingKey", c, u, o, R ? x : d), a) {
                    const I = this.resolve(o, { ...n,
                        keySeparator: !1
                    });
                    I && I.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
                }
                let J = [];
                const G = this.languageUtils.getFallbackCodes(this.options.fallbackLng, n.lng || this.language);
                if (this.options.saveMissingTo === "fallback" && G && G[0])
                    for (let I = 0; I < G.length; I++) J.push(G[I]);
                else this.options.saveMissingTo === "all" ? J = this.languageUtils.toResolveHierarchy(n.lng || this.language) : J.push(n.lng || this.language);
                const me = (I, K, W) => {
                    const ye = k && W !== d ? W : j;
                    this.options.missingKeyHandler ? this.options.missingKeyHandler(I, u, K, ye, R, n) : this.backendConnector ? .saveMissing && this.backendConnector.saveMissing(I, u, K, ye, R, n), this.emit("missingKey", I, u, K, d)
                };
                this.options.saveMissing && (this.options.saveMissingPlurals && S ? J.forEach(I => {
                    const K = this.pluralResolver.getSuffixes(I, n);
                    g && n[`defaultValue${this.options.pluralSeparator}zero`] && K.indexOf(`${this.options.pluralSeparator}zero`) < 0 && K.push(`${this.options.pluralSeparator}zero`), K.forEach(W => {
                        me([I], o + W, n[`defaultValue${W}`] || x)
                    })
                }) : me(J, o, x))
            }
            d = this.extendTranslation(d, e, n, h, s), A && d === o && this.options.appendNamespaceToMissingKey && (d = `${u}${f}${o}`), (A || P) && this.options.parseMissingKeyHandler && (d = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${u}${f}${o}` : o, P ? d : void 0, n))
        }
        return r ? (h.res = d, h.usedParams = this.getUsedParamsDetails(n), h) : d
    }
    extendTranslation(e, t, s, n, r) {
        if (this.i18nFormat ? .parse) e = this.i18nFormat.parse(e, { ...this.options.interpolation.defaultVariables,
            ...s
        }, s.lng || this.language || n.usedLng, n.usedNS, n.usedKey, {
            resolved: n
        });
        else if (!s.skipInterpolation) {
            s.interpolation && this.interpolator.init({ ...s,
                interpolation: { ...this.options.interpolation,
                    ...s.interpolation
                }
            });
            const l = y(e) && (s ? .interpolation ? .skipOnVariables !== void 0 ? s.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
            let u;
            if (l) {
                const c = e.match(this.interpolator.nestingRegexp);
                u = c && c.length
            }
            let f = s.replace && !y(s.replace) ? s.replace : s;
            if (this.options.interpolation.defaultVariables && (f = { ...this.options.interpolation.defaultVariables,
                    ...f
                }), e = this.interpolator.interpolate(e, f, s.lng || this.language || n.usedLng, s), l) {
                const c = e.match(this.interpolator.nestingRegexp),
                    p = c && c.length;
                u < p && (s.nest = !1)
            }!s.lng && n && n.res && (s.lng = this.language || n.usedLng), s.nest !== !1 && (e = this.interpolator.nest(e, (...c) => r ? .[0] === c[0] && !s.context ? (this.logger.warn(`It seems you are nesting recursively key: ${c[0]} in key: ${t[0]}`), null) : this.translate(...c, t), s)), s.interpolation && this.interpolator.reset()
        }
        const a = s.postProcess || this.options.postProcess,
            o = y(a) ? [a] : a;
        return e != null && o ? .length && s.applyPostProcessor !== !1 && (e = Ke.handle(o, e, t, this.options && this.options.postProcessPassResolved ? {
            i18nResolved: { ...n,
                usedParams: this.getUsedParamsDetails(s)
            },
            ...s
        } : s, this)), e
    }
    resolve(e, t = {}) {
        let s, n, r, a, o;
        return y(e) && (e = [e]), e.forEach(l => {
            if (this.isValidLookup(s)) return;
            const u = this.extractFromKey(l, t),
                f = u.key;
            n = f;
            let c = u.namespaces;
            this.options.fallbackNS && (c = c.concat(this.options.fallbackNS));
            const p = t.count !== void 0 && !y(t.count),
                h = p && !t.ordinal && t.count === 0,
                d = t.context !== void 0 && (y(t.context) || typeof t.context == "number") && t.context !== "",
                L = t.lngs ? t.lngs : this.languageUtils.toResolveHierarchy(t.lng || this.language, t.fallbackLng);
            c.forEach(O => {
                this.isValidLookup(s) || (o = O, !ve[`${L[0]}-${O}`] && this.utils ? .hasLoadedNamespace && !this.utils ? .hasLoadedNamespace(o) && (ve[`${L[0]}-${O}`] = !0, this.logger.warn(`key "${n}" for languages "${L.join(", ")}" won't get resolved as namespace "${o}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), L.forEach(E => {
                    if (this.isValidLookup(s)) return;
                    a = E;
                    const w = [f];
                    if (this.i18nFormat ? .addLookupKeys) this.i18nFormat.addLookupKeys(w, f, E, O, t);
                    else {
                        let S;
                        p && (S = this.pluralResolver.getSuffix(E, t.count, t));
                        const k = `${this.options.pluralSeparator}zero`,
                            T = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                        if (p && (t.ordinal && S.indexOf(T) === 0 && w.push(f + S.replace(T, this.options.pluralSeparator)), w.push(f + S), h && w.push(f + k)), d) {
                            const C = `${f}${this.options.contextSeparator||"_"}${t.context}`;
                            w.push(C), p && (t.ordinal && S.indexOf(T) === 0 && w.push(C + S.replace(T, this.options.pluralSeparator)), w.push(C + S), h && w.push(C + k))
                        }
                    }
                    let N;
                    for (; N = w.pop();) this.isValidLookup(s) || (r = N, s = this.getResource(E, O, N, t))
                }))
            })
        }), {
            res: s,
            usedKey: n,
            exactUsedKey: r,
            usedLng: a,
            usedNS: o
        }
    }
    isValidLookup(e) {
        return e !== void 0 && !(!this.options.returnNull && e === null) && !(!this.options.returnEmptyString && e === "")
    }
    getResource(e, t, s, n = {}) {
        return this.i18nFormat ? .getResource ? this.i18nFormat.getResource(e, t, s, n) : this.resourceStore.getResource(e, t, s, n)
    }
    getUsedParamsDetails(e = {}) {
        const t = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"],
            s = e.replace && !y(e.replace);
        let n = s ? e.replace : e;
        if (s && typeof e.count < "u" && (n.count = e.count), this.options.interpolation.defaultVariables && (n = { ...this.options.interpolation.defaultVariables,
                ...n
            }), !s) {
            n = { ...n
            };
            for (const r of t) delete n[r]
        }
        return n
    }
    static hasDefaultValue(e) {
        const t = "defaultValue";
        for (const s in e)
            if (Object.prototype.hasOwnProperty.call(e, s) && t === s.substring(0, t.length) && e[s] !== void 0) return !0;
        return !1
    }
}
class Le {
    constructor(e) {
        this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = V.create("languageUtils")
    }
    getScriptPartFromCode(e) {
        if (e = q(e), !e || e.indexOf("-") < 0) return null;
        const t = e.split("-");
        return t.length === 2 || (t.pop(), t[t.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(t.join("-"))
    }
    getLanguagePartFromCode(e) {
        if (e = q(e), !e || e.indexOf("-") < 0) return e;
        const t = e.split("-");
        return this.formatLanguageCode(t[0])
    }
    formatLanguageCode(e) {
        if (y(e) && e.indexOf("-") > -1) {
            let t;
            try {
                t = Intl.getCanonicalLocales(e)[0]
            } catch {}
            return t && this.options.lowerCaseLng && (t = t.toLowerCase()), t || (this.options.lowerCaseLng ? e.toLowerCase() : e)
        }
        return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e
    }
    isSupportedCode(e) {
        return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1
    }
    getBestMatchFromCodes(e) {
        if (!e) return null;
        let t;
        return e.forEach(s => {
            if (t) return;
            const n = this.formatLanguageCode(s);
            (!this.options.supportedLngs || this.isSupportedCode(n)) && (t = n)
        }), !t && this.options.supportedLngs && e.forEach(s => {
            if (t) return;
            const n = this.getScriptPartFromCode(s);
            if (this.isSupportedCode(n)) return t = n;
            const r = this.getLanguagePartFromCode(s);
            if (this.isSupportedCode(r)) return t = r;
            t = this.options.supportedLngs.find(a => {
                if (a === r) return a;
                if (!(a.indexOf("-") < 0 && r.indexOf("-") < 0) && (a.indexOf("-") > 0 && r.indexOf("-") < 0 && a.substring(0, a.indexOf("-")) === r || a.indexOf(r) === 0 && r.length > 1)) return a
            })
        }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t
    }
    getFallbackCodes(e, t) {
        if (!e) return [];
        if (typeof e == "function" && (e = e(t)), y(e) && (e = [e]), Array.isArray(e)) return e;
        if (!t) return e.default || [];
        let s = e[t];
        return s || (s = e[this.getScriptPartFromCode(t)]), s || (s = e[this.formatLanguageCode(t)]), s || (s = e[this.getLanguagePartFromCode(t)]), s || (s = e.default), s || []
    }
    toResolveHierarchy(e, t) {
        const s = this.getFallbackCodes((t === !1 ? [] : t) || this.options.fallbackLng || [], e),
            n = [],
            r = a => {
                a && (this.isSupportedCode(a) ? n.push(a) : this.logger.warn(`rejecting language code not found in supportedLngs: ${a}`))
            };
        return y(e) && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && r(this.formatLanguageCode(e)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && r(this.getScriptPartFromCode(e)), this.options.load !== "currentOnly" && r(this.getLanguagePartFromCode(e))) : y(e) && r(this.formatLanguageCode(e)), s.forEach(a => {
            n.indexOf(a) < 0 && r(this.formatLanguageCode(a))
        }), n
    }
}
const Ce = {
        zero: 0,
        one: 1,
        two: 2,
        few: 3,
        many: 4,
        other: 5
    },
    Ne = {
        select: i => i === 1 ? "one" : "other",
        resolvedOptions: () => ({
            pluralCategories: ["one", "other"]
        })
    };
class ft {
    constructor(e, t = {}) {
        this.languageUtils = e, this.options = t, this.logger = V.create("pluralResolver"), this.pluralRulesCache = {}
    }
    addRule(e, t) {
        this.rules[e] = t
    }
    clearCache() {
        this.pluralRulesCache = {}
    }
    getRule(e, t = {}) {
        const s = q(e === "dev" ? "en" : e),
            n = t.ordinal ? "ordinal" : "cardinal",
            r = JSON.stringify({
                cleanedCode: s,
                type: n
            });
        if (r in this.pluralRulesCache) return this.pluralRulesCache[r];
        let a;
        try {
            a = new Intl.PluralRules(s, {
                type: n
            })
        } catch {
            if (!Intl) return this.logger.error("No Intl support, please use an Intl polyfill!"), Ne;
            if (!e.match(/-|_/)) return Ne;
            const l = this.languageUtils.getLanguagePartFromCode(e);
            a = this.getRule(l, t)
        }
        return this.pluralRulesCache[r] = a, a
    }
    needsPlural(e, t = {}) {
        let s = this.getRule(e, t);
        return s || (s = this.getRule("dev", t)), s ? .resolvedOptions().pluralCategories.length > 1
    }
    getPluralFormsOfKey(e, t, s = {}) {
        return this.getSuffixes(e, s).map(n => `${t}${n}`)
    }
    getSuffixes(e, t = {}) {
        let s = this.getRule(e, t);
        return s || (s = this.getRule("dev", t)), s ? s.resolvedOptions().pluralCategories.sort((n, r) => Ce[n] - Ce[r]).map(n => `${this.options.prepend}${t.ordinal?`ordinal${this.options.prepend}`:""}${n}`) : []
    }
    getSuffix(e, t, s = {}) {
        const n = this.getRule(e, s);
        return n ? `${this.options.prepend}${s.ordinal?`ordinal${this.options.prepend}`:""}${n.select(t)}` : (this.logger.warn(`no plural rule found for: ${e}`), this.getSuffix("dev", t, s))
    }
}
const ke = (i, e, t, s = ".", n = !0) => {
        let r = st(i, e, t);
        return !r && n && y(t) && (r = de(i, t, s), r === void 0 && (r = de(e, t, s))), r
    },
    le = i => i.replace(/\$/g, "$$$$");
class dt {
    constructor(e = {}) {
        this.logger = V.create("interpolator"), this.options = e, this.format = e ? .interpolation ? .format || (t => t), this.init(e)
    }
    init(e = {}) {
        e.interpolation || (e.interpolation = {
            escapeValue: !0
        });
        const {
            escape: t,
            escapeValue: s,
            useRawValueToEscape: n,
            prefix: r,
            prefixEscaped: a,
            suffix: o,
            suffixEscaped: l,
            formatSeparator: u,
            unescapeSuffix: f,
            unescapePrefix: c,
            nestingPrefix: p,
            nestingPrefixEscaped: h,
            nestingSuffix: d,
            nestingSuffixEscaped: L,
            nestingOptionsSeparator: O,
            maxReplaces: E,
            alwaysFormat: w
        } = e.interpolation;
        this.escape = t !== void 0 ? t : it, this.escapeValue = s !== void 0 ? s : !0, this.useRawValueToEscape = n !== void 0 ? n : !1, this.prefix = r ? H(r) : a || "{{", this.suffix = o ? H(o) : l || "}}", this.formatSeparator = u || ",", this.unescapePrefix = f ? "" : c || "-", this.unescapeSuffix = this.unescapePrefix ? "" : f || "", this.nestingPrefix = p ? H(p) : h || H("$t("), this.nestingSuffix = d ? H(d) : L || H(")"), this.nestingOptionsSeparator = O || ",", this.maxReplaces = E || 1e3, this.alwaysFormat = w !== void 0 ? w : !1, this.resetRegExp()
    }
    reset() {
        this.options && this.init(this.options)
    }
    resetRegExp() {
        const e = (t, s) => t ? .source === s ? (t.lastIndex = 0, t) : new RegExp(s, "g");
        this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`)
    }
    interpolate(e, t, s, n) {
        let r, a, o;
        const l = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {},
            u = h => {
                if (h.indexOf(this.formatSeparator) < 0) {
                    const E = ke(t, l, h, this.options.keySeparator, this.options.ignoreJSONStructure);
                    return this.alwaysFormat ? this.format(E, void 0, s, { ...n,
                        ...t,
                        interpolationkey: h
                    }) : E
                }
                const d = h.split(this.formatSeparator),
                    L = d.shift().trim(),
                    O = d.join(this.formatSeparator).trim();
                return this.format(ke(t, l, L, this.options.keySeparator, this.options.ignoreJSONStructure), O, s, { ...n,
                    ...t,
                    interpolationkey: L
                })
            };
        this.resetRegExp();
        const f = n ? .missingInterpolationHandler || this.options.missingInterpolationHandler,
            c = n ? .interpolation ? .skipOnVariables !== void 0 ? n.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
        return [{
            regex: this.regexpUnescape,
            safeValue: h => le(h)
        }, {
            regex: this.regexp,
            safeValue: h => this.escapeValue ? le(this.escape(h)) : le(h)
        }].forEach(h => {
            for (o = 0; r = h.regex.exec(e);) {
                const d = r[1].trim();
                if (a = u(d), a === void 0)
                    if (typeof f == "function") {
                        const O = f(e, r, n);
                        a = y(O) ? O : ""
                    } else if (n && Object.prototype.hasOwnProperty.call(n, d)) a = "";
                else if (c) {
                    a = r[0];
                    continue
                } else this.logger.warn(`missed to pass in variable ${d} for interpolating ${e}`), a = "";
                else !y(a) && !this.useRawValueToEscape && (a = xe(a));
                const L = h.safeValue(a);
                if (e = e.replace(r[0], L), c ? (h.regex.lastIndex += a.length, h.regex.lastIndex -= r[0].length) : h.regex.lastIndex = 0, o++, o >= this.maxReplaces) break
            }
        }), e
    }
    nest(e, t, s = {}) {
        let n, r, a;
        const o = (l, u) => {
            const f = this.nestingOptionsSeparator;
            if (l.indexOf(f) < 0) return l;
            const c = l.split(new RegExp(`${f}[ ]*{`));
            let p = `{${c[1]}`;
            l = c[0], p = this.interpolate(p, a);
            const h = p.match(/'/g),
                d = p.match(/"/g);
            ((h ? .length ? ? 0) % 2 === 0 && !d || d.length % 2 !== 0) && (p = p.replace(/'/g, '"'));
            try {
                a = JSON.parse(p), u && (a = { ...u,
                    ...a
                })
            } catch (L) {
                return this.logger.warn(`failed parsing options string in nesting for key ${l}`, L), `${l}${f}${p}`
            }
            return a.defaultValue && a.defaultValue.indexOf(this.prefix) > -1 && delete a.defaultValue, l
        };
        for (; n = this.nestingRegexp.exec(e);) {
            let l = [];
            a = { ...s
            }, a = a.replace && !y(a.replace) ? a.replace : a, a.applyPostProcessor = !1, delete a.defaultValue;
            const u = /{.*}/.test(n[1]) ? n[1].lastIndexOf("}") + 1 : n[1].indexOf(this.formatSeparator);
            if (u !== -1 && (l = n[1].slice(u).split(this.formatSeparator).map(f => f.trim()).filter(Boolean), n[1] = n[1].slice(0, u)), r = t(o.call(this, n[1].trim(), a), a), r && n[0] === e && !y(r)) return r;
            y(r) || (r = xe(r)), r || (this.logger.warn(`missed to resolve ${n[1]} for nesting ${e}`), r = ""), l.length && (r = l.reduce((f, c) => this.format(f, c, s.lng, { ...s,
                interpolationkey: n[1].trim()
            }), r.trim())), e = e.replace(n[0], r), this.regexp.lastIndex = 0
        }
        return e
    }
}
const ht = i => {
        let e = i.toLowerCase().trim();
        const t = {};
        if (i.indexOf("(") > -1) {
            const s = i.split("(");
            e = s[0].toLowerCase().trim();
            const n = s[1].substring(0, s[1].length - 1);
            e === "currency" && n.indexOf(":") < 0 ? t.currency || (t.currency = n.trim()) : e === "relativetime" && n.indexOf(":") < 0 ? t.range || (t.range = n.trim()) : n.split(";").forEach(a => {
                if (a) {
                    const [o, ...l] = a.split(":"), u = l.join(":").trim().replace(/^'+|'+$/g, ""), f = o.trim();
                    t[f] || (t[f] = u), u === "false" && (t[f] = !1), u === "true" && (t[f] = !0), isNaN(u) || (t[f] = parseInt(u, 10))
                }
            })
        }
        return {
            formatName: e,
            formatOptions: t
        }
    },
    $e = i => {
        const e = {};
        return (t, s, n) => {
            let r = n;
            n && n.interpolationkey && n.formatParams && n.formatParams[n.interpolationkey] && n[n.interpolationkey] && (r = { ...r,
                [n.interpolationkey]: void 0
            });
            const a = s + JSON.stringify(r);
            let o = e[a];
            return o || (o = i(q(s), n), e[a] = o), o(t)
        }
    },
    pt = i => (e, t, s) => i(q(t), s)(e);
class gt {
    constructor(e = {}) {
        this.logger = V.create("formatter"), this.options = e, this.init(e)
    }
    init(e, t = {
        interpolation: {}
    }) {
        this.formatSeparator = t.interpolation.formatSeparator || ",";
        const s = t.cacheInBuiltFormats ? $e : pt;
        this.formats = {
            number: s((n, r) => {
                const a = new Intl.NumberFormat(n, { ...r
                });
                return o => a.format(o)
            }),
            currency: s((n, r) => {
                const a = new Intl.NumberFormat(n, { ...r,
                    style: "currency"
                });
                return o => a.format(o)
            }),
            datetime: s((n, r) => {
                const a = new Intl.DateTimeFormat(n, { ...r
                });
                return o => a.format(o)
            }),
            relativetime: s((n, r) => {
                const a = new Intl.RelativeTimeFormat(n, { ...r
                });
                return o => a.format(o, r.range || "day")
            }),
            list: s((n, r) => {
                const a = new Intl.ListFormat(n, { ...r
                });
                return o => a.format(o)
            })
        }
    }
    add(e, t) {
        this.formats[e.toLowerCase().trim()] = t
    }
    addCached(e, t) {
        this.formats[e.toLowerCase().trim()] = $e(t)
    }
    format(e, t, s, n = {}) {
        const r = t.split(this.formatSeparator);
        if (r.length > 1 && r[0].indexOf("(") > 1 && r[0].indexOf(")") < 0 && r.find(o => o.indexOf(")") > -1)) {
            const o = r.findIndex(l => l.indexOf(")") > -1);
            r[0] = [r[0], ...r.splice(1, o)].join(this.formatSeparator)
        }
        return r.reduce((o, l) => {
            const {
                formatName: u,
                formatOptions: f
            } = ht(l);
            if (this.formats[u]) {
                let c = o;
                try {
                    const p = n ? .formatParams ? .[n.interpolationkey] || {},
                        h = p.locale || p.lng || n.locale || n.lng || s;
                    c = this.formats[u](o, h, { ...f,
                        ...n,
                        ...p
                    })
                } catch (p) {
                    this.logger.warn(p)
                }
                return c
            } else this.logger.warn(`there was no format function for ${u}`);
            return o
        }, e)
    }
}
const mt = (i, e) => {
    i.pending[e] !== void 0 && (delete i.pending[e], i.pendingCount--)
};
class yt extends re {
    constructor(e, t, s, n = {}) {
        super(), this.backend = e, this.store = t, this.services = s, this.languageUtils = s.languageUtils, this.options = n, this.logger = V.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = n.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = n.maxRetries >= 0 ? n.maxRetries : 5, this.retryTimeout = n.retryTimeout >= 1 ? n.retryTimeout : 350, this.state = {}, this.queue = [], this.backend ? .init ? .(s, n.backend, n)
    }
    queueLoad(e, t, s, n) {
        const r = {},
            a = {},
            o = {},
            l = {};
        return e.forEach(u => {
            let f = !0;
            t.forEach(c => {
                const p = `${u}|${c}`;
                !s.reload && this.store.hasResourceBundle(u, c) ? this.state[p] = 2 : this.state[p] < 0 || (this.state[p] === 1 ? a[p] === void 0 && (a[p] = !0) : (this.state[p] = 1, f = !1, a[p] === void 0 && (a[p] = !0), r[p] === void 0 && (r[p] = !0), l[c] === void 0 && (l[c] = !0)))
            }), f || (o[u] = !0)
        }), (Object.keys(r).length || Object.keys(a).length) && this.queue.push({
            pending: a,
            pendingCount: Object.keys(a).length,
            loaded: {},
            errors: [],
            callback: n
        }), {
            toLoad: Object.keys(r),
            pending: Object.keys(a),
            toLoadLanguages: Object.keys(o),
            toLoadNamespaces: Object.keys(l)
        }
    }
    loaded(e, t, s) {
        const n = e.split("|"),
            r = n[0],
            a = n[1];
        t && this.emit("failedLoading", r, a, t), !t && s && this.store.addResourceBundle(r, a, s, void 0, void 0, {
            skipCopy: !0
        }), this.state[e] = t ? -1 : 2, t && s && (this.state[e] = 0);
        const o = {};
        this.queue.forEach(l => {
            tt(l.loaded, [r], a), mt(l, e), t && l.errors.push(t), l.pendingCount === 0 && !l.done && (Object.keys(l.loaded).forEach(u => {
                o[u] || (o[u] = {});
                const f = l.loaded[u];
                f.length && f.forEach(c => {
                    o[u][c] === void 0 && (o[u][c] = !0)
                })
            }), l.done = !0, l.errors.length ? l.callback(l.errors) : l.callback())
        }), this.emit("loaded", o), this.queue = this.queue.filter(l => !l.done)
    }
    read(e, t, s, n = 0, r = this.retryTimeout, a) {
        if (!e.length) return a(null, {});
        if (this.readingCalls >= this.maxParallelReads) {
            this.waitingReads.push({
                lng: e,
                ns: t,
                fcName: s,
                tried: n,
                wait: r,
                callback: a
            });
            return
        }
        this.readingCalls++;
        const o = (u, f) => {
                if (this.readingCalls--, this.waitingReads.length > 0) {
                    const c = this.waitingReads.shift();
                    this.read(c.lng, c.ns, c.fcName, c.tried, c.wait, c.callback)
                }
                if (u && f && n < this.maxRetries) {
                    setTimeout(() => {
                        this.read.call(this, e, t, s, n + 1, r * 2, a)
                    }, r);
                    return
                }
                a(u, f)
            },
            l = this.backend[s].bind(this.backend);
        if (l.length === 2) {
            try {
                const u = l(e, t);
                u && typeof u.then == "function" ? u.then(f => o(null, f)).catch(o) : o(null, u)
            } catch (u) {
                o(u)
            }
            return
        }
        return l(e, t, o)
    }
    prepareLoading(e, t, s = {}, n) {
        if (!this.backend) return this.logger.warn("No backend was added via i18next.use. Will not load resources."), n && n();
        y(e) && (e = this.languageUtils.toResolveHierarchy(e)), y(t) && (t = [t]);
        const r = this.queueLoad(e, t, s, n);
        if (!r.toLoad.length) return r.pending.length || n(), null;
        r.toLoad.forEach(a => {
            this.loadOne(a)
        })
    }
    load(e, t, s) {
        this.prepareLoading(e, t, {}, s)
    }
    reload(e, t, s) {
        this.prepareLoading(e, t, {
            reload: !0
        }, s)
    }
    loadOne(e, t = "") {
        const s = e.split("|"),
            n = s[0],
            r = s[1];
        this.read(n, r, "read", void 0, void 0, (a, o) => {
            a && this.logger.warn(`${t}loading namespace ${r} for language ${n} failed`, a), !a && o && this.logger.log(`${t}loaded namespace ${r} for language ${n}`, o), this.loaded(e, a, o)
        })
    }
    saveMissing(e, t, s, n, r, a = {}, o = () => {}) {
        if (this.services ? .utils ? .hasLoadedNamespace && !this.services ? .utils ? .hasLoadedNamespace(t)) {
            this.logger.warn(`did not save key "${s}" as the namespace "${t}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
            return
        }
        if (!(s == null || s === "")) {
            if (this.backend ? .create) {
                const l = { ...a,
                        isUpdate: r
                    },
                    u = this.backend.create.bind(this.backend);
                if (u.length < 6) try {
                    let f;
                    u.length === 5 ? f = u(e, t, s, n, l) : f = u(e, t, s, n), f && typeof f.then == "function" ? f.then(c => o(null, c)).catch(o) : o(null, f)
                } catch (f) {
                    o(f)
                } else u(e, t, s, n, o, l)
            }!e || !e[0] || this.store.addResource(e[0], t, s, n)
        }
    }
}
const Ee = () => ({
        debug: !1,
        initAsync: !0,
        ns: ["translation"],
        defaultNS: ["translation"],
        fallbackLng: ["dev"],
        fallbackNS: !1,
        supportedLngs: !1,
        nonExplicitSupportedLngs: !1,
        load: "all",
        preload: !1,
        simplifyPluralSuffix: !0,
        keySeparator: ".",
        nsSeparator: ":",
        pluralSeparator: "_",
        contextSeparator: "_",
        partialBundledLanguages: !1,
        saveMissing: !1,
        updateMissing: !1,
        saveMissingTo: "fallback",
        saveMissingPlurals: !0,
        missingKeyHandler: !1,
        missingInterpolationHandler: !1,
        postProcess: !1,
        postProcessPassResolved: !1,
        returnNull: !1,
        returnEmptyString: !0,
        returnObjects: !1,
        joinArrays: !1,
        returnedObjectHandler: !1,
        parseMissingKeyHandler: !1,
        appendNamespaceToMissingKey: !1,
        appendNamespaceToCIMode: !1,
        overloadTranslationOptionHandler: i => {
            let e = {};
            if (typeof i[1] == "object" && (e = i[1]), y(i[1]) && (e.defaultValue = i[1]), y(i[2]) && (e.tDescription = i[2]), typeof i[2] == "object" || typeof i[3] == "object") {
                const t = i[3] || i[2];
                Object.keys(t).forEach(s => {
                    e[s] = t[s]
                })
            }
            return e
        },
        interpolation: {
            escapeValue: !0,
            format: i => i,
            prefix: "{{",
            suffix: "}}",
            formatSeparator: ",",
            unescapePrefix: "-",
            nestingPrefix: "$t(",
            nestingSuffix: ")",
            nestingOptionsSeparator: ",",
            maxReplaces: 1e3,
            skipOnVariables: !0
        },
        cacheInBuiltFormats: !0
    }),
    Re = i => (y(i.ns) && (i.ns = [i.ns]), y(i.fallbackLng) && (i.fallbackLng = [i.fallbackLng]), y(i.fallbackNS) && (i.fallbackNS = [i.fallbackNS]), i.supportedLngs ? .indexOf ? .("cimode") < 0 && (i.supportedLngs = i.supportedLngs.concat(["cimode"])), typeof i.initImmediate == "boolean" && (i.initAsync = i.initImmediate), i),
    X = () => {},
    xt = i => {
        Object.getOwnPropertyNames(Object.getPrototypeOf(i)).forEach(t => {
            typeof i[t] == "function" && (i[t] = i[t].bind(i))
        })
    };
class Z extends re {
    constructor(e = {}, t) {
        if (super(), this.options = Re(e), this.services = {}, this.logger = V, this.modules = {
                external: []
            }, xt(this), t && !this.isInitialized && !e.isClone) {
            if (!this.options.initAsync) return this.init(e, t), this;
            setTimeout(() => {
                this.init(e, t)
            }, 0)
        }
    }
    init(e = {}, t) {
        this.isInitializing = !0, typeof e == "function" && (t = e, e = {}), e.defaultNS == null && e.ns && (y(e.ns) ? e.defaultNS = e.ns : e.ns.indexOf("translation") < 0 && (e.defaultNS = e.ns[0]));
        const s = Ee();
        this.options = { ...s,
            ...this.options,
            ...Re(e)
        }, this.options.interpolation = { ...s.interpolation,
            ...this.options.interpolation
        }, e.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = e.keySeparator), e.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = e.nsSeparator);
        const n = u => u ? typeof u == "function" ? new u : u : null;
        if (!this.options.isClone) {
            this.modules.logger ? V.init(n(this.modules.logger), this.options) : V.init(null, this.options);
            let u;
            this.modules.formatter ? u = this.modules.formatter : u = gt;
            const f = new Le(this.options);
            this.store = new Oe(this.options.resources, this.options);
            const c = this.services;
            c.logger = V, c.resourceStore = this.store, c.languageUtils = f, c.pluralResolver = new ft(f, {
                prepend: this.options.pluralSeparator,
                simplifyPluralSuffix: this.options.simplifyPluralSuffix
            }), this.options.interpolation.format && this.options.interpolation.format !== s.interpolation.format && this.logger.deprecate("init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting"), u && (!this.options.interpolation.format || this.options.interpolation.format === s.interpolation.format) && (c.formatter = n(u), c.formatter.init && c.formatter.init(c, this.options), this.options.interpolation.format = c.formatter.format.bind(c.formatter)), c.interpolator = new dt(this.options), c.utils = {
                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
            }, c.backendConnector = new yt(n(this.modules.backend), c.resourceStore, c, this.options), c.backendConnector.on("*", (h, ...d) => {
                this.emit(h, ...d)
            }), this.modules.languageDetector && (c.languageDetector = n(this.modules.languageDetector), c.languageDetector.init && c.languageDetector.init(c, this.options.detection, this.options)), this.modules.i18nFormat && (c.i18nFormat = n(this.modules.i18nFormat), c.i18nFormat.init && c.i18nFormat.init(this)), this.translator = new ie(this.services, this.options), this.translator.on("*", (h, ...d) => {
                this.emit(h, ...d)
            }), this.modules.external.forEach(h => {
                h.init && h.init(this)
            })
        }
        if (this.format = this.options.interpolation.format, t || (t = X), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
            const u = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            u.length > 0 && u[0] !== "dev" && (this.options.lng = u[0])
        }!this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(u => {
            this[u] = (...f) => this.store[u](...f)
        }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(u => {
            this[u] = (...f) => (this.store[u](...f), this)
        });
        const o = Y(),
            l = () => {
                const u = (f, c) => {
                    this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), o.resolve(c), t(f, c)
                };
                if (this.languages && !this.isInitialized) return u(null, this.t.bind(this));
                this.changeLanguage(this.options.lng, u)
            };
        return this.options.resources || !this.options.initAsync ? l() : setTimeout(l, 0), o
    }
    loadResources(e, t = X) {
        let s = t;
        const n = y(e) ? e : this.language;
        if (typeof e == "function" && (s = e), !this.options.resources || this.options.partialBundledLanguages) {
            if (n ? .toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return s();
            const r = [],
                a = o => {
                    if (!o || o === "cimode") return;
                    this.services.languageUtils.toResolveHierarchy(o).forEach(u => {
                        u !== "cimode" && r.indexOf(u) < 0 && r.push(u)
                    })
                };
            n ? a(n) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(l => a(l)), this.options.preload ? .forEach ? .(o => a(o)), this.services.backendConnector.load(r, this.options.ns, o => {
                !o && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), s(o)
            })
        } else s(null)
    }
    reloadResources(e, t, s) {
        const n = Y();
        return typeof e == "function" && (s = e, e = void 0), typeof t == "function" && (s = t, t = void 0), e || (e = this.languages), t || (t = this.options.ns), s || (s = X), this.services.backendConnector.reload(e, t, r => {
            n.resolve(), s(r)
        }), n
    }
    use(e) {
        if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
        if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
        return e.type === "backend" && (this.modules.backend = e), (e.type === "logger" || e.log && e.warn && e.error) && (this.modules.logger = e), e.type === "languageDetector" && (this.modules.languageDetector = e), e.type === "i18nFormat" && (this.modules.i18nFormat = e), e.type === "postProcessor" && Ke.addPostProcessor(e), e.type === "formatter" && (this.modules.formatter = e), e.type === "3rdParty" && this.modules.external.push(e), this
    }
    setResolvedLanguage(e) {
        if (!(!e || !this.languages) && !(["cimode", "dev"].indexOf(e) > -1)) {
            for (let t = 0; t < this.languages.length; t++) {
                const s = this.languages[t];
                if (!(["cimode", "dev"].indexOf(s) > -1) && this.store.hasLanguageSomeTranslations(s)) {
                    this.resolvedLanguage = s;
                    break
                }
            }!this.resolvedLanguage && this.languages.indexOf(e) < 0 && this.store.hasLanguageSomeTranslations(e) && (this.resolvedLanguage = e, this.languages.unshift(e))
        }
    }
    changeLanguage(e, t) {
        this.isLanguageChangingTo = e;
        const s = Y();
        this.emit("languageChanging", e);
        const n = o => {
                this.language = o, this.languages = this.services.languageUtils.toResolveHierarchy(o), this.resolvedLanguage = void 0, this.setResolvedLanguage(o)
            },
            r = (o, l) => {
                l ? this.isLanguageChangingTo === e && (n(l), this.translator.changeLanguage(l), this.isLanguageChangingTo = void 0, this.emit("languageChanged", l), this.logger.log("languageChanged", l)) : this.isLanguageChangingTo = void 0, s.resolve((...u) => this.t(...u)), t && t(o, (...u) => this.t(...u))
            },
            a = o => {
                !e && !o && this.services.languageDetector && (o = []);
                const l = y(o) ? o : o && o[0],
                    u = this.store.hasLanguageSomeTranslations(l) ? l : this.services.languageUtils.getBestMatchFromCodes(y(o) ? [o] : o);
                u && (this.language || n(u), this.translator.language || this.translator.changeLanguage(u), this.services.languageDetector ? .cacheUserLanguage ? .(u)), this.loadResources(u, f => {
                    r(f, u)
                })
            };
        return !e && this.services.languageDetector && !this.services.languageDetector.async ? a(this.services.languageDetector.detect()) : !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(a) : this.services.languageDetector.detect(a) : a(e), s
    }
    getFixedT(e, t, s) {
        const n = (r, a, ...o) => {
            let l;
            typeof a != "object" ? l = this.options.overloadTranslationOptionHandler([r, a].concat(o)) : l = { ...a
            }, l.lng = l.lng || n.lng, l.lngs = l.lngs || n.lngs, l.ns = l.ns || n.ns, l.keyPrefix !== "" && (l.keyPrefix = l.keyPrefix || s || n.keyPrefix);
            const u = this.options.keySeparator || ".";
            let f;
            return l.keyPrefix && Array.isArray(r) ? f = r.map(c => (typeof c == "function" && (c = ne(c, { ...this.options,
                ...a
            })), `${l.keyPrefix}${u}${c}`)) : (typeof r == "function" && (r = ne(r, { ...this.options,
                ...a
            })), f = l.keyPrefix ? `${l.keyPrefix}${u}${r}` : r), this.t(f, l)
        };
        return y(e) ? n.lng = e : n.lngs = e, n.ns = t, n.keyPrefix = s, n
    }
    t(...e) {
        return this.translator ? .translate(...e)
    }
    exists(...e) {
        return this.translator ? .exists(...e)
    }
    setDefaultNamespace(e) {
        this.options.defaultNS = e
    }
    hasLoadedNamespace(e, t = {}) {
        if (!this.isInitialized) return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
        if (!this.languages || !this.languages.length) return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
        const s = t.lng || this.resolvedLanguage || this.languages[0],
            n = this.options ? this.options.fallbackLng : !1,
            r = this.languages[this.languages.length - 1];
        if (s.toLowerCase() === "cimode") return !0;
        const a = (o, l) => {
            const u = this.services.backendConnector.state[`${o}|${l}`];
            return u === -1 || u === 0 || u === 2
        };
        if (t.precheck) {
            const o = t.precheck(this, a);
            if (o !== void 0) return o
        }
        return !!(this.hasResourceBundle(s, e) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || a(s, e) && (!n || a(r, e)))
    }
    loadNamespaces(e, t) {
        const s = Y();
        return this.options.ns ? (y(e) && (e = [e]), e.forEach(n => {
            this.options.ns.indexOf(n) < 0 && this.options.ns.push(n)
        }), this.loadResources(n => {
            s.resolve(), t && t(n)
        }), s) : (t && t(), Promise.resolve())
    }
    loadLanguages(e, t) {
        const s = Y();
        y(e) && (e = [e]);
        const n = this.options.preload || [],
            r = e.filter(a => n.indexOf(a) < 0 && this.services.languageUtils.isSupportedCode(a));
        return r.length ? (this.options.preload = n.concat(r), this.loadResources(a => {
            s.resolve(), t && t(a)
        }), s) : (t && t(), Promise.resolve())
    }
    dir(e) {
        if (e || (e = this.resolvedLanguage || (this.languages ? .length > 0 ? this.languages[0] : this.language)), !e) return "rtl";
        try {
            const n = new Intl.Locale(e);
            if (n && n.getTextInfo) {
                const r = n.getTextInfo();
                if (r && r.direction) return r.direction
            }
        } catch {}
        const t = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"],
            s = this.services ? .languageUtils || new Le(Ee());
        return e.toLowerCase().indexOf("-latn") > 1 ? "ltr" : t.indexOf(s.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr"
    }
    static createInstance(e = {}, t) {
        const s = new Z(e, t);
        return s.createInstance = Z.createInstance, s
    }
    cloneInstance(e = {}, t = X) {
        const s = e.forkResourceStore;
        s && delete e.forkResourceStore;
        const n = { ...this.options,
                ...e,
                isClone: !0
            },
            r = new Z(n);
        if ((e.debug !== void 0 || e.prefix !== void 0) && (r.logger = r.logger.clone(e)), ["store", "services", "language"].forEach(o => {
                r[o] = this[o]
            }), r.services = { ...this.services
            }, r.services.utils = {
                hasLoadedNamespace: r.hasLoadedNamespace.bind(r)
            }, s) {
            const o = Object.keys(this.store.data).reduce((l, u) => (l[u] = { ...this.store.data[u]
            }, l[u] = Object.keys(l[u]).reduce((f, c) => (f[c] = { ...l[u][c]
            }, f), l[u]), l), {});
            r.store = new Oe(o, n), r.services.resourceStore = r.store
        }
        return r.translator = new ie(r.services, n), r.translator.on("*", (o, ...l) => {
            r.emit(o, ...l)
        }), r.init(n, t), r.translator.options = n, r.translator.backendConnector.services.utils = {
            hasLoadedNamespace: r.hasLoadedNamespace.bind(r)
        }, r
    }
    toJSON() {
        return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages,
            resolvedLanguage: this.resolvedLanguage
        }
    }
}
const F = Z.createInstance();
F.createInstance;
F.dir;
F.init;
F.loadResources;
F.reloadResources;
F.use;
F.changeLanguage;
F.getFixedT;
F.t;
F.exists;
F.setDefaultNamespace;
F.hasLoadedNamespace;
F.loadNamespaces;
F.loadLanguages;
var ue, Pe;

function St() {
    return Pe || (Pe = 1, ue = {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    }), ue
}
var bt = St();
const wt = qe(bt);
var Ot = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;

function Te(i) {
    var e = {
            type: "tag",
            name: "",
            voidElement: !1,
            attrs: {},
            children: []
        },
        t = i.match(/<\/?([^\s]+?)[/\s>]/);
    if (t && (e.name = t[1], (wt[t[1]] || i.charAt(i.length - 2) === "/") && (e.voidElement = !0), e.name.startsWith("!--"))) {
        var s = i.indexOf("-->");
        return {
            type: "comment",
            comment: s !== -1 ? i.slice(4, s) : ""
        }
    }
    for (var n = new RegExp(Ot), r = null;
        (r = n.exec(i)) !== null;)
        if (r[0].trim())
            if (r[1]) {
                var a = r[1].trim(),
                    o = [a, ""];
                a.indexOf("=") > -1 && (o = a.split("=")), e.attrs[o[0]] = o[1], n.lastIndex--
            } else r[2] && (e.attrs[r[2]] = r[3].trim().substring(1, r[3].length - 1));
    return e
}
var vt = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g,
    Lt = /^\s*$/,
    Ct = Object.create(null);

function He(i, e) {
    switch (e.type) {
        case "text":
            return i + e.content;
        case "tag":
            return i += "<" + e.name + (e.attrs ? (function(t) {
                var s = [];
                for (var n in t) s.push(n + '="' + t[n] + '"');
                return s.length ? " " + s.join(" ") : ""
            })(e.attrs) : "") + (e.voidElement ? "/>" : ">"), e.voidElement ? i : i + e.children.reduce(He, "") + "</" + e.name + ">";
        case "comment":
            return i + "<!--" + e.comment + "-->"
    }
}
var Nt = {
    parse: function(i, e) {
        e || (e = {}), e.components || (e.components = Ct);
        var t, s = [],
            n = [],
            r = -1,
            a = !1;
        if (i.indexOf("<") !== 0) {
            var o = i.indexOf("<");
            s.push({
                type: "text",
                content: o === -1 ? i : i.substring(0, o)
            })
        }
        return i.replace(vt, function(l, u) {
            if (a) {
                if (l !== "</" + t.name + ">") return;
                a = !1
            }
            var f, c = l.charAt(1) !== "/",
                p = l.startsWith("<!--"),
                h = u + l.length,
                d = i.charAt(h);
            if (p) {
                var L = Te(l);
                return r < 0 ? (s.push(L), s) : ((f = n[r]).children.push(L), s)
            }
            if (c && (r++, (t = Te(l)).type === "tag" && e.components[t.name] && (t.type = "component", a = !0), t.voidElement || a || !d || d === "<" || t.children.push({
                    type: "text",
                    content: i.slice(h, i.indexOf("<", h))
                }), r === 0 && s.push(t), (f = n[r - 1]) && f.children.push(t), n[r] = t), (!c || t.voidElement) && (r > -1 && (t.voidElement || t.name === l.slice(2, -1)) && (r--, t = r === -1 ? s : n[r]), !a && d !== "<" && d)) {
                f = r === -1 ? s : n[r].children;
                var O = i.indexOf("<", h),
                    E = i.slice(h, O === -1 ? void 0 : O);
                Lt.test(E) && (E = " "), (O > -1 && r + f.length >= 0 || E !== " ") && f.push({
                    type: "text",
                    content: E
                })
            }
        }), s
    },
    stringify: function(i) {
        return i.reduce(function(e, t) {
            return e + He("", t)
        }, "")
    }
};
const ee = (i, e, t, s) => {
        const n = [t, {
            code: e,
            ...s || {}
        }];
        if (i ? .services ? .logger ? .forward) return i.services.logger.forward(n, "warn", "react-i18next::", !0);
        D(n[0]) && (n[0] = `react-i18next:: ${n[0]}`), i ? .services ? .logger ? .warn && i.services.logger.warn(...n)
    },
    Ae = {},
    ae = (i, e, t, s) => {
        D(t) && Ae[t] || (D(t) && (Ae[t] = new Date), ee(i, e, t, s))
    },
    ze = (i, e) => () => {
        if (i.isInitialized) e();
        else {
            const t = () => {
                setTimeout(() => {
                    i.off("initialized", t)
                }, 0), e()
            };
            i.on("initialized", t)
        }
    },
    he = (i, e, t) => {
        i.loadNamespaces(e, ze(i, t))
    },
    Fe = (i, e, t, s) => {
        if (D(t) && (t = [t]), i.options.preload && i.options.preload.indexOf(e) > -1) return he(i, t, s);
        t.forEach(n => {
            i.options.ns.indexOf(n) < 0 && i.options.ns.push(n)
        }), i.loadLanguages(e, ze(i, s))
    },
    kt = (i, e, t = {}) => !e.languages || !e.languages.length ? (ae(e, "NO_LANGUAGES", "i18n.languages were undefined or empty", {
        languages: e.languages
    }), !0) : e.hasLoadedNamespace(i, {
        lng: t.lng,
        precheck: (s, n) => {
            if (t.bindI18n && t.bindI18n.indexOf("languageChanging") > -1 && s.services.backendConnector.backend && s.isLanguageChangingTo && !n(s.isLanguageChangingTo, i)) return !1
        }
    }),
    D = i => typeof i == "string",
    U = i => typeof i == "object" && i !== null,
    $t = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,
    Et = {
        "&amp;": "&",
        "&#38;": "&",
        "&lt;": "<",
        "&#60;": "<",
        "&gt;": ">",
        "&#62;": ">",
        "&apos;": "'",
        "&#39;": "'",
        "&quot;": '"',
        "&#34;": '"',
        "&nbsp;": " ",
        "&#160;": " ",
        "&copy;": "",
        "&#169;": "",
        "&reg;": "",
        "&#174;": "",
        "&hellip;": "",
        "&#8230;": "",
        "&#x2F;": "/",
        "&#47;": "/"
    },
    Rt = i => Et[i],
    Pt = i => i.replace($t, Rt);
let pe = {
    bindI18n: "languageChanged",
    bindI18nStore: "",
    transEmptyNodeValue: "",
    transSupportBasicHtmlNodes: !0,
    transWrapTextNodes: "",
    transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
    useSuspense: !0,
    unescape: Pt
};
const Tt = (i = {}) => {
        pe = { ...pe,
            ...i
        }
    },
    Be = () => pe;
let _e;
const At = i => {
        _e = i
    },
    ge = () => _e,
    ce = (i, e) => {
        if (!i) return !1;
        const t = i.props ? .children ? ? i.children;
        return e ? t.length > 0 : !!t
    },
    fe = i => {
        if (!i) return [];
        const e = i.props ? .children ? ? i.children;
        return i.props ? .i18nIsDynamicList ? _(e) : e
    },
    Ft = i => Array.isArray(i) && i.every($.isValidElement),
    _ = i => Array.isArray(i) ? i : [i],
    It = (i, e) => {
        const t = { ...e
        };
        return t.props = Object.assign(i.props, e.props), t
    },
    Je = (i, e, t, s) => {
        if (!i) return "";
        let n = "";
        const r = _(i),
            a = e ? .transSupportBasicHtmlNodes ? e.transKeepBasicHtmlNodesFor ? ? [] : [];
        return r.forEach((o, l) => {
            if (D(o)) {
                n += `${o}`;
                return
            }
            if ($.isValidElement(o)) {
                const {
                    props: u,
                    type: f
                } = o, c = Object.keys(u).length, p = a.indexOf(f) > -1, h = u.children;
                if (!h && p && !c) {
                    n += `<${f}/>`;
                    return
                }
                if (!h && (!p || c) || u.i18nIsDynamicList) {
                    n += `<${l}></${l}>`;
                    return
                }
                if (p && c === 1 && D(h)) {
                    n += `<${f}>${h}</${f}>`;
                    return
                }
                const d = Je(h, e, t, s);
                n += `<${l}>${d}</${l}>`;
                return
            }
            if (o === null) {
                ee(t, "TRANS_NULL_VALUE", "Passed in a null value as child", {
                    i18nKey: s
                });
                return
            }
            if (U(o)) {
                const {
                    format: u,
                    ...f
                } = o, c = Object.keys(f);
                if (c.length === 1) {
                    const p = u ? `${c[0]}, ${u}` : c[0];
                    n += `{{${p}}}`;
                    return
                }
                ee(t, "TRANS_INVALID_OBJ", "Invalid child - Object should only have keys {{ value, format }} (format is optional).", {
                    i18nKey: s,
                    child: o
                });
                return
            }
            ee(t, "TRANS_INVALID_VAR", "Passed in a variable like {number} - pass variables for interpolation as full objects like {{number}}.", {
                i18nKey: s,
                child: o
            })
        }), n
    },
    jt = (i, e = [], t = {}) => {
        if (!i) return i;
        const s = Object.keys(t),
            n = [...e, ...s];
        let r = "",
            a = 0;
        for (; a < i.length;)
            if (i[a] === "<") {
                let o = !1;
                const l = i.slice(a).match(/^<\/(\d+|[a-zA-Z][a-zA-Z0-9-]*)>/);
                if (l) {
                    const u = l[1];
                    (/^\d+$/.test(u) || n.includes(u)) && (o = !0, r += l[0], a += l[0].length)
                }
                if (!o) {
                    const u = i.slice(a).match(/^<(\d+|[a-zA-Z][a-zA-Z0-9-]*)(\s+[\w-]+(?:=(?:"[^"]*"|'[^']*'|[^\s>]+))?)*\s*(\/)?>/);
                    if (u) {
                        const f = u[1];
                        (/^\d+$/.test(f) || n.includes(f)) && (o = !0, r += u[0], a += u[0].length)
                    }
                }
                o || (r += "&lt;", a += 1)
            } else r += i[a], a += 1;
        return r
    },
    Dt = (i, e, t, s, n, r, a) => {
        if (t === "") return [];
        const o = n.transKeepBasicHtmlNodesFor || [],
            l = t && new RegExp(o.map(w => `<${w}`).join("|")).test(t);
        if (!i && !e && !l && !a) return [t];
        const u = e ? ? {},
            f = w => {
                _(w).forEach(S => {
                    D(S) || (ce(S) ? f(fe(S)) : U(S) && !$.isValidElement(S) && Object.assign(u, S))
                })
            };
        f(i);
        const c = jt(t, o, u),
            p = Nt.parse(`<0>${c}</0>`),
            h = { ...u,
                ...r
            },
            d = (w, N, S) => {
                const k = fe(w),
                    T = O(k, N.children, S);
                return Ft(k) && T.length === 0 || w.props ? .i18nIsDynamicList ? k : T
            },
            L = (w, N, S, k, T) => {
                w.dummy ? (w.children = N, S.push($.cloneElement(w, {
                    key: k
                }, T ? void 0 : N))) : S.push(...$.Children.map([w], C => {
                    const g = "data-i18n-is-dynamic-list",
                        x = {
                            key: k,
                            [g]: void 0
                        };
                    return C && C.props && Object.keys(C.props).forEach(m => {
                        m === "ref" || m === "children" || m === "i18nIsDynamicList" || m === g || (x[m] = C.props[m])
                    }), $.cloneElement(C, x, T ? null : N)
                }))
            },
            O = (w, N, S) => {
                const k = _(w);
                return _(N).reduce((C, g, x) => {
                    const m = g.children ? .[0] ? .content && s.services.interpolator.interpolate(g.children[0].content, h, s.language);
                    if (g.type === "tag") {
                        let v = k[parseInt(g.name, 10)];
                        !v && e && (v = e[g.name]), S.length === 1 && !v && (v = S[0][g.name]), v || (v = {});
                        const b = Object.keys(g.attrs).length !== 0 ? It({
                                props: g.attrs
                            }, v) : v,
                            P = $.isValidElement(b),
                            A = P && ce(g, !0) && !g.voidElement,
                            M = l && U(b) && b.dummy && !P,
                            j = U(e) && Object.hasOwnProperty.call(e, g.name);
                        if (D(b)) {
                            const R = s.services.interpolator.interpolate(b, h, s.language);
                            C.push(R)
                        } else if (ce(b) || A) {
                            const R = d(b, g, S);
                            L(b, R, C, x)
                        } else if (M) {
                            const R = O(k, g.children, S);
                            L(b, R, C, x)
                        } else if (Number.isNaN(parseFloat(g.name)))
                            if (j) {
                                const R = d(b, g, S);
                                L(b, R, C, x, g.voidElement)
                            } else if (n.transSupportBasicHtmlNodes && o.indexOf(g.name) > -1)
                            if (g.voidElement) C.push($.createElement(g.name, {
                                key: `${g.name}-${x}`
                            }));
                            else {
                                const R = O(k, g.children, S);
                                C.push($.createElement(g.name, {
                                    key: `${g.name}-${x}`
                                }, R))
                            }
                        else if (g.voidElement) C.push(`<${g.name} />`);
                        else {
                            const R = O(k, g.children, S);
                            C.push(`<${g.name}>${R}</${g.name}>`)
                        } else if (U(b) && !P) {
                            const R = g.children[0] ? m : null;
                            R && C.push(R)
                        } else L(b, m, C, x, g.children.length !== 1 || !m)
                    } else if (g.type === "text") {
                        const v = n.transWrapTextNodes,
                            b = a ? n.unescape(s.services.interpolator.interpolate(g.content, h, s.language)) : s.services.interpolator.interpolate(g.content, h, s.language);
                        v ? C.push($.createElement(v, {
                            key: `${g.name}-${x}`
                        }, b)) : C.push(b)
                    }
                    return C
                }, [])
            },
            E = O([{
                dummy: !0,
                children: i || []
            }], p, _(i || []));
        return fe(E[0])
    },
    We = (i, e, t) => {
        const s = i.key || e,
            n = $.cloneElement(i, {
                key: s
            });
        if (!n.props || !n.props.children || t.indexOf(`${e}/>`) < 0 && t.indexOf(`${e} />`) < 0) return n;

        function r() {
            return $.createElement($.Fragment, null, n)
        }
        return $.createElement(r, {
            key: s
        })
    },
    Vt = (i, e) => i.map((t, s) => We(t, s, e)),
    Ut = (i, e) => {
        const t = {};
        return Object.keys(i).forEach(s => {
            Object.assign(t, {
                [s]: We(i[s], s, e)
            })
        }), t
    },
    Kt = (i, e, t, s) => i ? Array.isArray(i) ? Vt(i, e) : U(i) ? Ut(i, e) : (ae(t, "TRANS_INVALID_COMPONENTS", '<Trans /> "components" prop expects an object or array', {
        i18nKey: s
    }), null) : null,
    Mt = i => !U(i) || Array.isArray(i) ? !1 : Object.keys(i).reduce((e, t) => e && Number.isNaN(Number.parseFloat(t)), !0);

function Ht({
    children: i,
    count: e,
    parent: t,
    i18nKey: s,
    context: n,
    tOptions: r = {},
    values: a,
    defaults: o,
    components: l,
    ns: u,
    i18n: f,
    t: c,
    shouldUnescape: p,
    ...h
}) {
    const d = f || ge();
    if (!d) return ae(d, "NO_I18NEXT_INSTANCE", "Trans: You need to pass in an i18next instance using i18nextReactModule", {
        i18nKey: s
    }), i;
    const L = c || d.t.bind(d) || (A => A),
        O = { ...Be(),
            ...d.options ? .react
        };
    let E = u || L.ns || d.options ? .defaultNS;
    E = D(E) ? [E] : E || ["translation"];
    const w = Je(i, O, d, s),
        N = o || r ? .defaultValue || w || O.transEmptyNodeValue || (typeof s == "function" ? ne(s) : s),
        {
            hashTransKey: S
        } = O,
        k = s || (S ? S(w || N) : w || N);
    d.options ? .interpolation ? .defaultVariables && (a = a && Object.keys(a).length > 0 ? { ...a,
        ...d.options.interpolation.defaultVariables
    } : { ...d.options.interpolation.defaultVariables
    });
    const T = a || e !== void 0 && !d.options ? .interpolation ? .alwaysFormat || !i ? r.interpolation : {
            interpolation: { ...r.interpolation,
                prefix: "#$?",
                suffix: "?$#"
            }
        },
        C = { ...r,
            context: n || r.context,
            count: e,
            ...a,
            ...T,
            defaultValue: N,
            ns: E
        };
    let g = k ? L(k, C) : N;
    g === k && N && (g = N);
    const x = Kt(l, g, d, s);
    let m = x || i,
        v = null;
    Mt(x) && (v = x, m = i);
    const b = Dt(m, v, g, d, O, C, p),
        P = t ? ? O.defaultTransParent;
    return P ? $.createElement(P, h, b) : b
}
const fs = {
        type: "3rdParty",
        init(i) {
            Tt(i.options.react), At(i)
        }
    },
    Ye = $.createContext();
class zt {
    constructor() {
        this.usedNamespaces = {}
    }
    addUsedNamespaces(e) {
        e.forEach(t => {
            this.usedNamespaces[t] || (this.usedNamespaces[t] = !0)
        })
    }
    getUsedNamespaces() {
        return Object.keys(this.usedNamespaces)
    }
}

function ds({
    children: i,
    count: e,
    parent: t,
    i18nKey: s,
    context: n,
    tOptions: r = {},
    values: a,
    defaults: o,
    components: l,
    ns: u,
    i18n: f,
    t: c,
    shouldUnescape: p,
    ...h
}) {
    const {
        i18n: d,
        defaultNS: L
    } = $.useContext(Ye) || {}, O = f || d || ge(), E = c || O ? .t.bind(O);
    return Ht({
        children: i,
        count: e,
        parent: t,
        i18nKey: s,
        context: n,
        tOptions: r,
        values: a,
        defaults: o,
        components: l,
        ns: u || E ? .ns || L || O ? .options ? .defaultNS,
        i18n: O,
        t: c,
        shouldUnescape: p,
        ...h
    })
}
const Bt = (i, e) => D(e) ? e : U(e) && D(e.defaultValue) ? e.defaultValue : Array.isArray(i) ? i[i.length - 1] : i,
    _t = {
        t: Bt,
        ready: !1
    },
    Jt = () => () => {},
    hs = (i, e = {}) => {
        const {
            i18n: t
        } = e, {
            i18n: s,
            defaultNS: n
        } = $.useContext(Ye) || {}, r = t || s || ge();
        r && !r.reportNamespaces && (r.reportNamespaces = new zt), r || ae(r, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
        const a = $.useMemo(() => ({ ...Be(),
                ...r ? .options ? .react,
                ...e
            }), [r, e]),
            {
                useSuspense: o,
                keyPrefix: l
            } = a,
            u = i || n || r ? .options ? .defaultNS,
            f = D(u) ? [u] : u || ["translation"],
            c = $.useMemo(() => f, f);
        r ? .reportNamespaces ? .addUsedNamespaces ? .(c);
        const p = $.useRef(0),
            h = $.useCallback(x => {
                if (!r) return Jt;
                const {
                    bindI18n: m,
                    bindI18nStore: v
                } = a, b = () => {
                    p.current += 1, x()
                };
                return m && r.on(m, b), v && r.store.on(v, b), () => {
                    m && m.split(" ").forEach(P => r.off(P, b)), v && v.split(" ").forEach(P => r.store.off(P, b))
                }
            }, [r, a]),
            d = $.useRef(),
            L = $.useCallback(() => {
                if (!r) return _t;
                const x = !!(r.isInitialized || r.initializedStoreOnce) && c.every(M => kt(M, r, a)),
                    m = e.lng || r.language,
                    v = p.current,
                    b = d.current;
                if (b && b.ready === x && b.lng === m && b.keyPrefix === l && b.revision === v) return b;
                const A = {
                    t: r.getFixedT(m, a.nsMode === "fallback" ? c : c[0], l),
                    ready: x,
                    lng: m,
                    keyPrefix: l,
                    revision: v
                };
                return d.current = A, A
            }, [r, c, l, a, e.lng]),
            [O, E] = $.useState(0),
            {
                t: w,
                ready: N
            } = Ge.useSyncExternalStore(h, L, L);
        $.useEffect(() => {
            if (r && !N && !o) {
                const x = () => E(m => m + 1);
                e.lng ? Fe(r, e.lng, c, x) : he(r, c, x)
            }
        }, [r, e.lng, c, N, o, O]);
        const S = r || {},
            k = $.useRef(null),
            T = $.useRef(),
            C = x => {
                const m = Object.getOwnPropertyDescriptors(x);
                m.__original && delete m.__original;
                const v = Object.create(Object.getPrototypeOf(x), m);
                if (!Object.prototype.hasOwnProperty.call(v, "__original")) try {
                    Object.defineProperty(v, "__original", {
                        value: x,
                        writable: !1,
                        enumerable: !1,
                        configurable: !1
                    })
                } catch {}
                return v
            },
            g = $.useMemo(() => {
                const x = S,
                    m = x ? .language;
                let v = x;
                x && (k.current && k.current.__original === x ? T.current !== m ? (v = C(x), k.current = v, T.current = m) : v = k.current : (v = C(x), k.current = v, T.current = m));
                const b = [w, v, N];
                return b.t = w, b.i18n = v, b.ready = N, b
            }, [w, S, N, S.resolvedLanguage, S.language, S.languages]);
        if (r && o && !N) throw new Promise(x => {
            const m = () => x();
            e.lng ? Fe(r, e.lng, c, m) : he(r, c, m)
        });
        return g
    },
    {
        slice: Wt,
        forEach: Yt
    } = [];

function Qt(i) {
    return Yt.call(Wt.call(arguments, 1), e => {
        if (e)
            for (const t in e) i[t] === void 0 && (i[t] = e[t])
    }), i
}

function Zt(i) {
    return typeof i != "string" ? !1 : [/<\s*script.*?>/i, /<\s*\/\s*script\s*>/i, /<\s*img.*?on\w+\s*=/i, /<\s*\w+\s*on\w+\s*=.*?>/i, /javascript\s*:/i, /vbscript\s*:/i, /expression\s*\(/i, /eval\s*\(/i, /alert\s*\(/i, /document\.cookie/i, /document\.write\s*\(/i, /window\.location/i, /innerHTML/i].some(t => t.test(i))
}
const Ie = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/,
    qt = function(i, e) {
        const s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
                path: "/"
            },
            n = encodeURIComponent(e);
        let r = `${i}=${n}`;
        if (s.maxAge > 0) {
            const a = s.maxAge - 0;
            if (Number.isNaN(a)) throw new Error("maxAge should be a Number");
            r += `; Max-Age=${Math.floor(a)}`
        }
        if (s.domain) {
            if (!Ie.test(s.domain)) throw new TypeError("option domain is invalid");
            r += `; Domain=${s.domain}`
        }
        if (s.path) {
            if (!Ie.test(s.path)) throw new TypeError("option path is invalid");
            r += `; Path=${s.path}`
        }
        if (s.expires) {
            if (typeof s.expires.toUTCString != "function") throw new TypeError("option expires is invalid");
            r += `; Expires=${s.expires.toUTCString()}`
        }
        if (s.httpOnly && (r += "; HttpOnly"), s.secure && (r += "; Secure"), s.sameSite) switch (typeof s.sameSite == "string" ? s.sameSite.toLowerCase() : s.sameSite) {
            case !0:
                r += "; SameSite=Strict";
                break;
            case "lax":
                r += "; SameSite=Lax";
                break;
            case "strict":
                r += "; SameSite=Strict";
                break;
            case "none":
                r += "; SameSite=None";
                break;
            default:
                throw new TypeError("option sameSite is invalid")
        }
        return s.partitioned && (r += "; Partitioned"), r
    },
    je = {
        create(i, e, t, s) {
            let n = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
                path: "/",
                sameSite: "strict"
            };
            t && (n.expires = new Date, n.expires.setTime(n.expires.getTime() + t * 60 * 1e3)), s && (n.domain = s), document.cookie = qt(i, e, n)
        },
        read(i) {
            const e = `${i}=`,
                t = document.cookie.split(";");
            for (let s = 0; s < t.length; s++) {
                let n = t[s];
                for (; n.charAt(0) === " ";) n = n.substring(1, n.length);
                if (n.indexOf(e) === 0) return n.substring(e.length, n.length)
            }
            return null
        },
        remove(i, e) {
            this.create(i, "", -1, e)
        }
    };
var Gt = {
        name: "cookie",
        lookup(i) {
            let {
                lookupCookie: e
            } = i;
            if (e && typeof document < "u") return je.read(e) || void 0
        },
        cacheUserLanguage(i, e) {
            let {
                lookupCookie: t,
                cookieMinutes: s,
                cookieDomain: n,
                cookieOptions: r
            } = e;
            t && typeof document < "u" && je.create(t, i, s, n, r)
        }
    },
    Xt = {
        name: "querystring",
        lookup(i) {
            let {
                lookupQuerystring: e
            } = i, t;
            if (typeof window < "u") {
                let {
                    search: s
                } = window.location;
                !window.location.search && window.location.hash ? .indexOf("?") > -1 && (s = window.location.hash.substring(window.location.hash.indexOf("?")));
                const r = s.substring(1).split("&");
                for (let a = 0; a < r.length; a++) {
                    const o = r[a].indexOf("=");
                    o > 0 && r[a].substring(0, o) === e && (t = r[a].substring(o + 1))
                }
            }
            return t
        }
    },
    es = {
        name: "hash",
        lookup(i) {
            let {
                lookupHash: e,
                lookupFromHashIndex: t
            } = i, s;
            if (typeof window < "u") {
                const {
                    hash: n
                } = window.location;
                if (n && n.length > 2) {
                    const r = n.substring(1);
                    if (e) {
                        const a = r.split("&");
                        for (let o = 0; o < a.length; o++) {
                            const l = a[o].indexOf("=");
                            l > 0 && a[o].substring(0, l) === e && (s = a[o].substring(l + 1))
                        }
                    }
                    if (s) return s;
                    if (!s && t > -1) {
                        const a = n.match(/\/([a-zA-Z-]*)/g);
                        return Array.isArray(a) ? a[typeof t == "number" ? t : 0] ? .replace("/", "") : void 0
                    }
                }
            }
            return s
        }
    };
let z = null;
const De = () => {
    if (z !== null) return z;
    try {
        if (z = typeof window < "u" && window.localStorage !== null, !z) return !1;
        const i = "i18next.translate.boo";
        window.localStorage.setItem(i, "foo"), window.localStorage.removeItem(i)
    } catch {
        z = !1
    }
    return z
};
var ts = {
    name: "localStorage",
    lookup(i) {
        let {
            lookupLocalStorage: e
        } = i;
        if (e && De()) return window.localStorage.getItem(e) || void 0
    },
    cacheUserLanguage(i, e) {
        let {
            lookupLocalStorage: t
        } = e;
        t && De() && window.localStorage.setItem(t, i)
    }
};
let B = null;
const Ve = () => {
    if (B !== null) return B;
    try {
        if (B = typeof window < "u" && window.sessionStorage !== null, !B) return !1;
        const i = "i18next.translate.boo";
        window.sessionStorage.setItem(i, "foo"), window.sessionStorage.removeItem(i)
    } catch {
        B = !1
    }
    return B
};
var ss = {
        name: "sessionStorage",
        lookup(i) {
            let {
                lookupSessionStorage: e
            } = i;
            if (e && Ve()) return window.sessionStorage.getItem(e) || void 0
        },
        cacheUserLanguage(i, e) {
            let {
                lookupSessionStorage: t
            } = e;
            t && Ve() && window.sessionStorage.setItem(t, i)
        }
    },
    ns = {
        name: "navigator",
        lookup(i) {
            const e = [];
            if (typeof navigator < "u") {
                const {
                    languages: t,
                    userLanguage: s,
                    language: n
                } = navigator;
                if (t)
                    for (let r = 0; r < t.length; r++) e.push(t[r]);
                s && e.push(s), n && e.push(n)
            }
            return e.length > 0 ? e : void 0
        }
    },
    is = {
        name: "htmlTag",
        lookup(i) {
            let {
                htmlTag: e
            } = i, t;
            const s = e || (typeof document < "u" ? document.documentElement : null);
            return s && typeof s.getAttribute == "function" && (t = s.getAttribute("lang")), t
        }
    },
    rs = {
        name: "path",
        lookup(i) {
            let {
                lookupFromPathIndex: e
            } = i;
            if (typeof window > "u") return;
            const t = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
            return Array.isArray(t) ? t[typeof e == "number" ? e : 0] ? .replace("/", "") : void 0
        }
    },
    as = {
        name: "subdomain",
        lookup(i) {
            let {
                lookupFromSubdomainIndex: e
            } = i;
            const t = typeof e == "number" ? e + 1 : 1,
                s = typeof window < "u" && window.location ? .hostname ? .match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
            if (s) return s[t]
        }
    };
let Qe = !1;
try {
    document.cookie, Qe = !0
} catch {}
const Ze = ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"];
Qe || Ze.splice(1, 1);
const os = () => ({
    order: Ze,
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    convertDetectedLanguage: i => i
});
class ls {
    constructor(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.type = "languageDetector", this.detectors = {}, this.init(e, t)
    }
    init() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
                languageUtils: {}
            },
            t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        this.services = e, this.options = Qt(t, this.options || {}, os()), typeof this.options.convertDetectedLanguage == "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1 && (this.options.convertDetectedLanguage = n => n.replace("-", "_")), this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex), this.i18nOptions = s, this.addDetector(Gt), this.addDetector(Xt), this.addDetector(ts), this.addDetector(ss), this.addDetector(ns), this.addDetector(is), this.addDetector(rs), this.addDetector(as), this.addDetector(es)
    }
    addDetector(e) {
        return this.detectors[e.name] = e, this
    }
    detect() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.order,
            t = [];
        return e.forEach(s => {
            if (this.detectors[s]) {
                let n = this.detectors[s].lookup(this.options);
                n && typeof n == "string" && (n = [n]), n && (t = t.concat(n))
            }
        }), t = t.filter(s => s != null && !Zt(s)).map(s => this.options.convertDetectedLanguage(s)), this.services && this.services.languageUtils && this.services.languageUtils.getBestMatchFromCodes ? t : t.length > 0 ? t[0] : null
    }
    cacheUserLanguage(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.caches;
        t && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(e) > -1 || t.forEach(s => {
            this.detectors[s] && this.detectors[s].cacheUserLanguage(e, this.options)
        }))
    }
}
ls.type = "languageDetector";
export {
    ls as B, ds as T, fs as a, F as i, hs as u
};